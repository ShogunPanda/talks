---
config:
  theme: nearform
  dimensions:
    width: 2000
    height: 1120
  url: https://talks.cowtech.it
document:
  title: Don’t break GraphQL, extend it!
  author:
    name: Paolo Insogna
    descriptionShort: Staff Node.js Core and DX Engineer
    description: |
      Staff Node.js Core and
      Developer Experience Team
    email: paolo.insogna@nearform.com
    twitter: p_insogna
    github: ShogunPanda
  company:
    count: 300
    npm:
      monthly: 1B
      percentage: 8%
slides:
  - layout: cover
  - layout: hello
  - layout: hiring
  - title: Let’s celebrate GraphQL!
    content: We all know how this technology has made our life easier.
    image: '@talk/graphql.webp'
    classes:
      image: absolute -bottom-1_5sp left-2_5sp w-5sp !max-h-none
  - title: Why is it good?
    items:
      - icon: source-code
        title: Many resources, less overhead, expressive language
        text: You can ask for multiple resources in a single request and save network bandwidth.
      - icon: cut
        title: No overfetching or underfetching
        text: The server will return exactly the data we asked for. <em>This will return.</em>
      - icon: network
        title: Federation
        text: Multiple schemas can be easily joined.
  - title: Federation
    items:
      - icon: affiliate
        title: Split the schema in subgraphs
        text: This is great for separation of concerns.
      - icon: link
        title: Integration with remote services
        text: Each subgraph is handled by a separate service, possibly remote.
      - icon: thumb-down
        title: Only works with GraphQL service
        text: You can’t directly integrate with REST APIs or similar.
  - title: Serialization
    items:
      - icon: world
        title: GraphQL does not enforces a serialization format
        text: Developers are free to use whatever they want to.
      - icon: tools
        title: The network stack is your choice
        text: Neither the data format or the transfer protocol are mandated by the spec.
      - icon: star
        title: Let’s face the honest truth
        text: 99% (total arbitrary) of the times we are talking about JSON data exchanged over HTTP.
  - layout: half
    title: The server knows<br/>it better
    content:
      - It’s relative easy to attach new data sources to the server.
      - '<em class="text-nf-neon-blue">How to push additional data to a client that didn’t ask for it?</em>'
    image: '@talk/server.webp'
  - layout: image
    title: How to be proactive?
    image: '@talk/what-now.webp'
  - title: 'Happy case: we control everything'
    items:
      - index: 1
        title: Add new data to the server’s schema
        text: You should not break backward compatibility.
      - index: 2
        title: Verify the clients are still working
        text: Double checking that nothing broke is never a bad choice.
      - index: 3
        title: Update the clients
        text: Update queries in the client to use the new data.
  - layout: image
    title: Are we done?
    image: '@talk/happiness.webp'
  - layout: separator
    title: You already know the answer...
    image: '@talk/laugh.webp'
    classes:
      slide: bg-nf-brunch-pink
  - title: The happy case is mostly theoretical
    items:
      - icon: world
        title: You have to be in control of the clients
        text: You also have to consider users that don’t usually upgrade their applications often.
      - icon: device-cctv
        title: Nothing can go out of sight
        text: If even a single component is not updated at the right time, compatibility problems will arise.
      - icon: license
        title: Specification will be broken
        text: Even if the client is able to handle data it didn’t ask for, <em>we are breaking the specification</em>.
  - layout: raw
    content: |
      <h1 class="text-nf-midnight-blue no-border font-size-150pt line-height-1 m-0 p-0">BAD!
      <h1 class="text-white no-border font-size-150pt line-height-1 m-0 p-0">DON'T!
    classes:
      slide: bg-nf-brunch-pink items-center justify-center p-0
      raw: flex flex-1 w-full h-full flex-col items-center justify-center
    logo: white
  - layout: image
    title: Do we have a choice?
    image: '@talk/alternatives.webp'
  - title: Meet GraphQL extensions
    content: The `extensions` field is already documented in the specification and it's perfect to ensure both compatibility and expandability.
    items:
      - icon: source-code
        title: Extensions are for developers
        text: The specification specifically states that field is reserved for developers to extend the protocol.
      - icon: circuit-changeover
        title: Existing clients will ignore them
        text: Unless configured to, clients will ignore the field and the server is still specification compliant.
    options:
      horizontal: true
  - title: "Let's implement an enriching proxy"
    items:
      - index: 1
        title: Analyze the query
        text: Parse and validate the query received by the client. In case of request error, stop here.
      - index: 2
        title: Ensure types information with temporary modifications
        text: Each selection set must contain the type to give all information to the enriching handler.
      - index: 3
        title: Execute the query
        text: This can be done directly on the server or we can create an enriching GraphQL proxy server.
      - index: 4
        title: Fetch the additional data
        text: Using a tree traversal algorithm, fetch additional data for each field according to the handler.
      - index: 5
        title: Enrich the response
        text: Store the additional data in the extensions field, using the JSONPath selector as the key.
    options:
      noGap: true
  - title: Check it out!
    content:
      - We can reuse the parsing and serialization from the reference GraphQL Javascript implementation.
      - qr: https://github.com/ShogunPanda/graphql-enrich-proxy
      - <span class="font-bold block text-center">[https://github.com/ShogunPanda/graphql-enrich-proxy](https://github.com/ShogunPanda/graphql-enrich-proxy)</span>
    classes:
      qr: w-2sp h-2sp mx-auto mb-0_2sp flex-1
  - layout: code
    title: Overview
    code:
      language: javascript
      highlight: '2'
      content: |
        import fastify from 'fastify'
        import { parse, print, visit } from 'graphql/language/index.js'

        /* ... */

        server.post('/graphql', async function handleQuery(req, reply) {
          // Step 1: Parse the query and check for syntax error
          const document = parse(req.body.query)

          // Step 2: Add types information to the query
          const [enrichedAst, enrichedId] = addTypesInformation(document)

          // Step 3: Execute the query on the upstream
          const response = await graphql('https://api.geographql.rudio.dev', print(enrichedAst))

          // Step 4 and 5: Execute the enriching handler to fetch additional data
          const extensions = await enrich(response.data, enrichedId, addWeatherInformation)

          // Return to the client
          return { ...response, extensions: { ...response.extensions, ...extensions }}
        })
  - layout: side
    title: Leveraging types
    content:
      - We make sure `__typename` is in all selection sets so we can easily parse the response.
    items:
      - icon: tool
        title: The added fields are temporary
        text: Never return these to the client.
      - icon: replace
        title: Leverage field aliasing
        text: Use field aliasing to easily spot the fields added.
    code:
      language: graphql
      highlight: 3, 6, 9
      content: |
        query test {
          hero {
            __typename
            name
            friends {
              __enriched: __typename
              name
              homeWorld {
                aliasedType: __typename
                __enriched: __typename
                name
                climate
              }
            }
          }
        }
  - layout: side
    title: Ensuring type information
    content: The visit API and the AST from the GraphQL reference implementation makes our life very easy.
    code:
      language: javascript
      highlight: '10, 14, 17, 23'
      content: |
        function injectedTypeField(id) {
          return {
            kind: 'Field',
            alias: { kind: 'Name', value: id },
            name: { kind: 'Name', value: '__typename' }
          }
        }

        function addTypesInformation(document) {
          const injectedFieldId = `enrichType_${Date.now()}`
          const injectedField = injectedTypeField(injectedFieldId)

          const updatedDocument = visit(document, {
            SelectionSet(node) {
              // Check if the type is already included unaliased
              for (const f of node.selections) {
                if (f.name.value === '__typename' && !f.alias) {
                  return
                }
              }

              // If we got there, we still have to add the typename
              node.selections.unshift(injectedField)
              return node
            }
          })

          return [updatedDocument, injectedFieldId]
        }
  - title: Cache the queries
    content: Parsing and executing GraphQL is expensive. Cache them when possible.
    items:
      - icon: cloud-upload
        title: Cache the original query…
        text: This also includes invalid queries as it will speed up the handling of misbehaving clients.
      - icon: replace
        title: …and the enriched query
        text: Traversing a complex query to ensure types information can be time consuming.
    options:
      horizontal: true
  - layout: separator
    title: Let me introduce two friends...
    classes:
      slide: bg-nf-brunch-pink
  - title: Depth first tree traversal
    image: '@talk/tree.webp'
  - layout: side
    title: JSONPath
    content: It is a string syntax for selecting and extracting values within a JSON value.
    items:
      - icon: star
        title: Well known
        text: You are already using JSONPath or similar.
      - icon: tools
        title: Easily implementable
        text: The syntax is easy to understand and implement.
    code:
      language: console
      numbers: false
      content: |
        $ cat example.json
        {
          "countries": [
            { "name": "Iceland", capital: "Reykjavík", },
            { "name": "Italy", capital: "Roma" }
          ]
        }

        $ jq ".countries[1].capital" example.json
        "Roma"
  - layout: separator
    title: ... and now the show goes on!
    classes:
      slide: bg-nf-orange-split
  - layout: side
    title: Enrich the data
    content:
      - We traverse the upstream response, executing the handler on each node.
      - If data is returned from the handler, we append to the extension using JSONPath.
    code:
      language: javascript
      highlight: '4, 8, 18, 22'
      content: |
        async function enrich(data, enrichedId, handler) {
          const extensions = {}

          await traverse(data, async function (value, path) {
            // Execute the handler on the node
            // and eventually add the returned data
            const additional = await handler(
              value.__typename || value[enrichedId],
              path,
              value
            )

            if (additional) {
              const jsonPath = path
                .join('.')
                .replace(/\.(\d+)\./g, '[$1].')

              extensions[jsonPath] = additional
            }

            // Make sure we remove any fields we added
            value[enrichedId] = undefined
          })

          return extensions
        }
  - layout: side
    title: Tree traversal
    content: Implementing a depth first tree traversal is quite easy when using recursion.
    code:
      language: javascript
      highlight: '5, 9, 14, 17, 21'
      content: |
        async function traverse(current, path, visitor) {
          // This is to handle the initial call
          if (typeof path === 'function') {
            visitor = path
            path = ['$']
          }

          // First of all, call the visitor on the current object
          await visitor(current, path)

          // For each enumerable property in the object,
          // perform a depth first traverse of the property
          // if it is an array of objects or an object.
          for (const [key, val] of Object.entries(current)) {
            if (Array.isArray(val)) {
              for (let i = 0; i < val.length; i += 1) {
                await traverse(val[i], path.concat(key, i), visitor)
              }
              // Say thanks to JS typing for the null checking
            } else if (typeof val === 'object' && val !== null) {
              await traverse(val, path.concat(key), visitor)
            }
          }
        }
  - layout: side
    title: Fetch the additional data
    content: Using the type and/or the path we can choose whether the node needs additional data.
    code:
      language: javascript
      highlight: '2, 7, 16, 18'
      content: |
        async function addWeatherInformation(type, path, value) {
          if (type !== 'City') {
            return
          }

          // Get weather information for today for the city
          const response = await undici.request(
            'https://goweather.herokuapp.com',
            {
              method: 'GET',
              path: `/weather/${value.name}`,
              dispatcher: agent
            }
          )

          const body = JSON.parse(await getStream(response.body))

          return response.statusCode === 200
            ? { temperature: body.temperature }
            : {
                error: {
                  statusCode: response.statusCode,
                  body
                }
              }
        }
  - layout: separator
    title: Only an example can enlighten us!
    classes:
      slide: bg-nf-orange-split
    image: '@talk/sun.webp'
  - layout: code
    title: Input query
    code:
      language: graphql
      highlight: 3, 7
      content: |
        {
          country(iso2: "US") {
            aliasedType: __typename
            name
            cities(page: {first: 2}) {
              __typename
              edges {
                node {
                  name
                }
              }
            }
          }
        }
  - layout: code
    title: Query executed from the upstream
    code:
      language: graphql
      highlight: 2, 4, 11, 13
      content: |
        {
          enrichType_1677506561773: __typename
          country(iso2: "US") {
            enrichType_1677506561773: __typename
            aliasedType: __typename
            name
            cities(page: {first: 2}) {
              __typename
              edges {
                enrichType_1677506561773: __typename
                node {
                  enrichType_1677506561773: __typename
                  name
                }
              }
            }
          }
        }
  - layout: side
    title: Upstream response
    content: It contains the enriched type information that will be removed from the final response.
    code:
      language: json
      highlight: 3, 5, 12, 14, 19, 21
      content: |
        {
          "data": {
            "enrichType_1677506561773": "Query",
            "country": {
              "enrichType_1677506561773": "Country",
              "aliasedType": "Country",
              "name": "United States",
              "cities": {
                "__typename": "CityConnection",
                "edges": [
                  {
                    "enrichType_1677506561773": "CityEdge",
                    "node": {
                      "enrichType_1677506561773": "City",
                      "name": "Abbeville"
                    }
                  },
                  {
                    "enrichType_1677506561773": "CityEdge",
                    "node": {
                      "enrichType_1677506561773": "City",
                      "name": "Alabaster"
                    }
                  }
                ]
              }
            }
          }
        }
  - layout: side
    title: Final proxy response (1/2)
    content: The client will receive the original data requested ...
    code:
      language: json
      content: |
        {
          "data": {
            "country": {
              "aliasedType": "Country",
              "name": "United States",
              "iso": "US",
              "cities": {
                "__typename": "CityConnection",
                "edges": [
                  {
                    "node": {
                      "name": "Abbeville"
                    }
                  },
                  {
                    "node": {
                      "name": "Adamsville"
                    }
                  }
                ]
              }
            }
          },
          "extensions": {
            /* ... */
          }
        }
  - layout: side
    title: Final proxy response (2/2)
    content: ...and all our enriched data is in the extensions field.
    code:
      language: graphql
      highlight: 6, 9
      content: |
        {
          "data": {
            /* ... */
          },
          "extensions": {
            "$.country.cities.edges[0].node": {
              "temperature": "+5 °C"
            },
            "$.country.cities.edges[1].node": {
              "error": {
                "statusCode": 404,
                "body": {
                  "message": "NOT_FOUND"
                }
              }
            }
          }
        }
  - layout: separator
    title: Mission completed!
    image: '@talk/completed.webp'
    icon: confetti
    classes:
      slide: bg-nf-darkest-blue
      icon: w-2_5sp h-2_5sp left-1sp -bottom-0_4sp text-white stroke-width-0_3
    notes: |
      Do a nice victory gesture and shout!
  - title: Take home lessons
    content: What can we learn from this long journey?
    items:
      - icon: license
        title: Read the specification
        text: The specifications are formal and verbose but they <em>might already contain what you need</em>.
      - icon: checkup-list
        title: Be compliant
        text: Even if peers are lenient with specification break, they might stop at any time. <em>Don’t risk!</em>
      - icon: search
        title: Analyse the environment
        text: Even if you develop the experience end to end, you will never be able to <em>cannot control everything</em>.
    options:
      horizontal: true
  - layout: quote
    sentence: You are remembered for the rules you break.
    author: Douglas MacArthur
  - layout: questions
  - layout: end
